print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
print(mcmc$w)
if(r == 10){
data$n_subtrees <- 3
}
}
data$s[18]
mcmc$a_g
mcmc$lambda_g
mcmc$t[18]
mm <- matrix(0, 1000, 1000)
max(min(parallel::detectCores(), floor(n / 100)), 1)
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Initially: chop up the tree into just one piece. After r sufficiently large, chop into more pieces
mcmcs <- breakdown(mcmc, data)
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(mcmcs, local_mcmc, data = data, mc.cores = data$n_subtrees)
#...or run in series
# all_res <- list()
# for (j in 1:data$n_subtrees) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], data)
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, data)
# Record amalgamated results
output <- c(output, amalgam)
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
print(mcmc$w)
if(r == 10){
data$n_subtrees <- 3
}
}
library(ape)
fasta <- read.FASTA("~/Desktop/100k/2023_03_16.aligned.fasta")
combined_vcf <- read.table("~/Desktop/100k/allvariants copy.tsv")
nrow(combined_vcf)
names <- names(fasta)
head(combined_vcf)
names
names <- gsub("\\|.*", "", names)
names
sum(names %in% combined_vcf$V9)
combined_vcf$V9
length(unique(combined_vcf$V9))
names <- gsub("\\_", "\\-", names)
combined_vcf$V9 <- gsub("\\_", "\\-", combined_vcf$V9)
sum(names %in% combined_vcf$V9)
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
#load("./input_data_huge/data.RData")
#load("./input_data_huge/mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(
1:data$n_subtrees,
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.cores = data$n_subtrees
)
#...or run in series
# all_res <- list()
# for (j in 1:data$n_subtrees) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results
output <- c(output, amalgam)
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
if(r == 10){
data$n_subtrees <- 3
}
}
mcmc[c("n", "w")]
length(output)
output[[22]]
record
names(mcmc)
record = c("n", "h", "w", "t", "b", "a_g", "lambda_g", "a_s", "lambda_s", "mu", "p", "v", "rho", "psi")
data$record <- record
i = 1
amalgam[[i]]
amalgam[[i]][data$record]
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
#load("./input_data_huge/data.RData")
#load("./input_data_huge/mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(
1:data$n_subtrees,
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.cores = data$n_subtrees
)
#...or run in series
# all_res <- list()
# for (j in 1:data$n_subtrees) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
output
length(amalgam)
all_res
length(all_res)
local_mcmc <- function(mcmc, data){
#set.seed(210)
res <- list()
#
# mcmc <- mcmcs[[j]]
# data <- datas[[j]]
# data$n_local <- 1
for (r in 1:data$n_local) {
mcmc <- moves$w(mcmc, data)
mcmc <- moves$t(mcmc, data)
# Unhash when running on VM
#mcmc <- moves$swap(mcmc, data, exchange_children = T)
mcmc <- moves$h_step(mcmc, data, resample_t = T)
mcmc <- moves$genotype(mcmc, data)
#
mcmc <- moves$h_global(mcmc, data)
mcmc <- moves$create(mcmc, data)
mcmc <- moves$w_t(mcmc, data)
mcmc <- moves$h_step(mcmc, data)
mcmc <- moves$swap(mcmc, data)
mcmc <- moves$h_step(mcmc, data, resample_t = T, resample_w = T)
if(r %% data$sample_every == 0){
res <- c(res, list(mcmc))
}
#print(r)
}
return(res)
}
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
#load("./input_data_huge/data.RData")
#load("./input_data_huge/mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(
1:data$n_subtrees,
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.cores = data$n_subtrees
)
#...or run in series
# all_res <- list()
# for (j in 1:data$n_subtrees) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
if(r == 10){
data$n_subtrees <- 3
}
}
1:data$n_subtrees
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
#load("./input_data_huge/data.RData")
#load("./input_data_huge/mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(
1:data$n_subtrees,
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.cores = data$n_subtrees
)
#...or run in series
# all_res <- list()
# for (j in 1:data$n_subtrees) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
if(r == 10){
data$n_subtrees <- 3
}
}
load("./input_data_huge/data.RData")
data$n_subtrees = 224
record = c("n", "h", "w", "t", "b", "a_g", "lambda_g", "a_s", "lambda_s", "mu", "p", "v", "rho", "psi")
data$record <- record
data$n_local
data$n_subtrees
data$n_global
data$n_global <- 1000
data$sample_every = 100
data$n_local = 100
save(data, file = "~/Desktop/thesis/input_data_huge/data.RData")
data$n_local = 1000
save(data, file = "~/Desktop/thesis/input_data_huge/data.RData")
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
#init <- initialize()
#mcmc <- init[[1]]
#data <- init[[2]]
## Unhash these for run on pre-computed data and initial MCMC
load("data.RData")
load("mcmc.RData")
### M-H algo
output <- list()
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
mcmcs[[100]]
mcmcs[[120]]$cluster
mcmcs[[300]]$cluster
mcmcs[[224]]$cluster
mcmcs[[1]]$cluster
mcmcs[[10]]$cluster
mcmcs[[160]]$cluster
mcmcs[[161]]$cluster
mcmcs[[200]]$cluster
mcmcs[[300]]$cluster
mcmcs[[210]]$cluster
mcmcs[[220]]$cluster
mcmcs[[224]]$cluster
mcmc$d
Inf < Inf
# Chop tree into roughly equally sized pieces
chop <- function(mcmc, data){
n <- length(mcmc$h)
out <- list()
roots <- c()
deg <- total_degree(mcmc$h, mcmc$d)
if(data$n_subtrees > 1){
for (i in 1:(data$n_subtrees - 1)) {
# On average, a branch should have n/data$n_subtrees nodes
prob <- rep(0,n)
prob[deg > 0.7*n/data$n_subtrees & deg < 1.3*n/data$n_subtrees] <- 1 # Everything close to n/data$n_subtrees gets probability 1
# Not allowed to choose "1", else the algo will end too early
prob[1] <- 0
# Also, something that makes our lives much easier: only allow observed hosts with observed parents to be roots
if(n > data$n_obs){
prob[(data$n_obs):n] <- 0
prob[which(mcmc$h > data$n_obs)] <- 0
}
# If everything is 0, just pick the one closest to the target value
if(all(prob == 0)){
dists <- abs(n/data$n_subtrees - deg)
dists[1] <- Inf
if(n > data$n_obs){
dists[(data$n_obs):n] <- Inf
dists[which(mcmc$h > data$n_obs)] <- Inf
}
pos_pick <- dists
pos_pick[n/data$n_subtrees > deg] <- Inf
if(any(pos_pick < Inf)){
pick <- which.min(pos_pick)
}else{
pick <- which.min(dists)
}
}else{
pick <- sample(1:n, 1, prob = prob)
}
anc <- ancestry(mcmc$h, pick)
deg[anc] <- deg[anc] - deg[pick]
ups <- get_upstream(mcmc$h, pick)
ups <- setdiff(ups, unlist(out))
deg[ups] <- 0
out[[i]] <- sort(ups)
# Set the ancestor of "ups" to a dummy, to save compute time on "get_upstream"
mcmc$h[ups] <- 0
roots[i] <- pick
#print(i)
}
}
out[[data$n_subtrees]] <- sort(setdiff(2:n, unlist(out)))
roots[data$n_subtrees] <- 1
return(list(roots, out))
}
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
n <- length(mcmc$h)
out <- list()
roots <- c()
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
load("data.RData")
load("mcmc.RData")
data$n_subtrees
### M-H algo
output <- list()
liks <- c()
n <- length(mcmc$h)
out <- list()
roots <- c()
deg <- total_degree(mcmc$h, mcmc$d)
deg
