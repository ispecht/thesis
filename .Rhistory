coord_fixed() +
theme(legend.position = 'none')
p
}
## Plot current ancestry
plot_current <- function(h, n_obs){
n <- length(h)
vertices <- data.frame(name = 1:n)
edges <- as.data.frame(cbind(paste(h[2:n]), paste(2:n)))
colnames(edges) <- c('from', 'to')
g <- graph_from_data_frame(edges)
colors <- rep('black', n)
colors[1:n > n_obs] <- 'gray'
p <- ggraph(edges, layout = 'dendrogram') +
geom_edge_elbow() +
geom_node_point(aes(color = as.numeric(name) > n_obs), size = 5) +
geom_node_text(aes(label=name), size=2.5, color = 'white') +
scale_color_manual(values = c("black", "gray")) +
theme_graph() +
coord_fixed() +
theme(legend.position = 'none')
p
}
plot_current(output[[10000]]$h, 45261)
library(ggplot2)
library(ggraph)
plot_current(output[[10000]]$h, 45261)
library(igraph)
plot_current(output[[10000]]$h, 45261)
version
rnorm(1000,0,100)
contributors()
library(ggplot2)
library(ggraph)
library(igraph)
# Load in results
load("output.RData")
output[[1]]
output[[1]]$mu
mus <- c()
for (i in 1:10000) {
mus[i] <- output[[i]]$mu
}
hist(mus)
hist(mus[2000:10000])
hist(3*mus[2000:10000])
1e-3
1e-3/365
mus[10000]
mu = mus[10000]
1/4 -(1/4)*exp(-mu)
mus <- c()
ps <- c()
for (i in 1:10000) {
mus[i] <- output[[i]]$mu
ps[i] <- output[[i]]$p
}
hist(ps)
hist(ps[2000:10000])
ps
rnorm(10000, 1e-7)
rnorm(10000, 0, 1e-7)
min(abs(rnorm(10000, 0, 1e-7)))
min(abs(rnorm(1000, 0, 1e-7)))
### Execute large-scale outbreak reconstruction algorithm
set.seed(220)
## Libraries
library(ape)
library(Rcpp)
#library(igraph)
#library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_subtrees = 12
## Unhash these for run on pre-computed data and initial MCMC
# load("data.RData")
# load("mcmc.RData")
### M-H algo
output <- list()
liks <- c()
data$n_global
data$n_local
data$record
data$sample_every
for (r in 1:data$n_global) {
# For reproducible results
set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
save(mcmcs, file = "mcmcs.RData")
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
#print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
### Execute large-scale outbreak reconstruction algorithm
set.seed(220)
## Libraries
library(ape)
library(Rcpp)
#library(igraph)
#library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_subtrees = 12
## Unhash these for run on pre-computed data and initial MCMC
# load("data.RData")
# load("mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
save(mcmcs, file = "mcmcs.RData")
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
#print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
print(plot_current(mcmc$h, data$n_obs))
mcmc$t[159]
mcmc$h[159]
mcmc$m01[159]
48 / 739.251
data$n_bases
mcmc$h[160]
mcmc$m01[[160]]
mcmc$m01
mcmc$m01[[125]]
mcmc$m10
48 / mcmc$t[159]
48 / mcmc$t[159] / 29903
i=159
mcmc0 <- mcmc
mcmc$g_lik[i]
mcmc$mu = 2.171373e-06
g_lik(mcmc, data, i)
mcmc$mu = 1e-05
g_lik(mcmc, data, i)
sum(mcmc0$g_lik)
sum(mcmc0$g_lik[2:mcmc$n])
mcmc$mu = 2.17e-06
sum(sapply(2:mcmc$n, g_lik, mcmc=mcmc, data=data))
mcmc$h
mcmc$w
### Execute large-scale outbreak reconstruction algorithm
set.seed(220)
## Libraries
library(ape)
library(Rcpp)
#library(igraph)
#library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_subtrees = 12
## Unhash these for run on pre-computed data and initial MCMC
# load("data.RData")
# load("mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
save(mcmcs, file = "mcmcs.RData")
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
#print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
mcmc$t - mcmc$t[mcmc$h]
sum(mcmc$t - mcmc$t[mcmc$h], na.rm = T)
mcmc$a_g
mcmc$lambda_g
mcmc$a_s
mcmc$lambda_s
hist(mcmc$t - mcmc$t[mcmc$h])
hist((mcmc$t - mcmc$t[mcmc$h])]-195)
hist((mcmc$t - mcmc$t[mcmc$h])[-159])
data$s
hist(data$s[-1])
### Execute large-scale outbreak reconstruction algorithm
set.seed(220)
## Libraries
library(ape)
library(Rcpp)
#library(igraph)
#library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_subtrees = 12
## Unhash these for run on pre-computed data and initial MCMC
# load("data.RData")
# load("mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
save(mcmcs, file = "mcmcs.RData")
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
#print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
mus <- c()
ps <- c()
bs <- c()
vs <- c()
for (i in 1:10000) {
mus[i] <- output[[i]]$mu
ps[i] <- output[[i]]$p
bs[i] <- output[[i]]$b
vs[i] <- output[[i]]$v
}
output
# Load in results
load("output.RData")
mus <- c()
ps <- c()
bs <- c()
vs <- c()
for (i in 1:10000) {
mus[i] <- output[[i]]$mu
ps[i] <- output[[i]]$p
bs[i] <- output[[i]]$b
vs[i] <- output[[i]]$v
}
bs
hist(bs)
