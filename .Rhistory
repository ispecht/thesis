}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
lfactorial(data$N)
log(data$N)
data$N
data$N = 1000
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
data$N = 100000
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
data$N = 1000
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
data$N = 10000
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
data$N
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 12
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <-  -lchoose(data$N, mcmc$w[i]) - lfactorial(mcmc$w[i]) -
(-lchoose(data$N, prop$w[i])) + lfactorial(prop$w[i])
}else if(change < 0){
hastings <-  -lchoose(data$N, mcmc$w[i]) - lfactorial(mcmc$w[i]) -
(-lchoose(data$N, prop$w[i])) + lfactorial(prop$w[i])
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
data$N
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
data$N = 100000
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
data$N = 100000
mcmc$e_lik <- e_lik(mcmc, data)
for (r in 1:10000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[12])
}
data$N <- 10000
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
### Execute large-scale outbreak reconstruction algorithm
set.seed(213)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Initially: chop up the tree into just one piece. After r sufficiently large, chop into more pieces
mcmcs <- breakdown(mcmc, data)
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(mcmcs, local_mcmc, data = data, mc.cores = data$n_subtrees)
#...or run in series
# all_res <- list()
# for (j in 1:data$n_subtrees) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], data)
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, data)
# Record amalgamated results
output <- c(output, amalgam)
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
print(paste(r * data$n_local * data$n_subtrees, "iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
print(mcmc$w)
if(r == 10){
data$n_subtrees <- 3
}
}
-change*log(data$N)
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <-  -lchoose(prop$w[i], change) -
(-change*log(data$N)) + lchoose(prop$w[i], change)
}else if(change < 0){
hastings <- -change*log(data$N) - lchoose(mcmc$w[i], change)
(-lchoose(mcmc$w[i], -change))
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[158])
}
data$N
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- -lchoose(prop$w[i], change) -
(-change*log(data$N)) + lchoose(prop$w[i], change)
}else if(change < 0){
hastings <- -change*log(data$N) - lchoose(mcmc$w[i], -change) -
(-lchoose(mcmc$w[i], -change))
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[158])
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- change*log(data$N)
}else if(change < 0){
hastings <- -change*log(data$N)
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[158])
}
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- change*log(data$N)
}else if(change < 0){
hastings <- change*log(data$N)
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <- moves$w(mcmc, data)
print(mcmc$w[158])
}
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
i <- sample(mcmc$cluster, 1)
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <-  -lchoose(prop$w[i], change) -
(-lchoose(data$N, change))
}else if(change < 0){
hastings <- -lchoose(data$N, -change) -
(-lchoose(mcmc$w[i], -change))
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
(log(mcmc$rho) + log((1-mcmc$psi) / mcmc$psi) - log(data$N))
log(mcmc$rho) + log((1-mcmc$psi) / mcmc$psi)
mcmc$h
mcmc$h[158]
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- change*log(data$N)
}else if(change < 0){
hastings <- change*log(data$N)
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- change*log(data$N)
}else if(change < 0){
hastings <- change*log(data$N)
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <-moves$w(mcmc, data)
print(mcmc$w[158])
}
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- change*log(data$N - sum(mcmc$w))
}else if(change < 0){
hastings <- change*log(data$N - sum(mcmc$w))
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <-moves$w(mcmc, data)
print(mcmc$w[158])
}
sum(mcmc$w)
## Update one of the w_i's by adding or subtracting either:
# rounded N(0, sqrt(delta_t * lambda_g / a_g))  (strategic) OR
# N(0, 3) (random)
moves$w <- function(mcmc, data){
# Choose random host with ancestor
#i <- sample(mcmc$cluster, 1)
i <- 158
h <- mcmc$h[i]
delta_t <- mcmc$t[i] - mcmc$t[h]
# Proposal
prop <- mcmc
if(delta_t > 50){
change <- round(rnorm(1, 0, sqrt(delta_t * mcmc$lambda_g / mcmc$a_g)))
}else{
change <- round(rnorm(1, 0, 3))
}
prop$w[i] <- mcmc$w[i] + change
prop$e_lik <- e_lik(prop, data)
prop$g_lik[i] <- g_lik(prop, data, i)
prop$prior <- prior(prop)
# Here the Hastings ratio is not 1, because we're imagining that the newly-added / deleted intermediate hosts are labeled.
if(change > 0){
# If added new hosts, P(new to old) is probability of correctly selecting the new hosts to delete
# P(old to new) is probability choosing the correct new hosts to add from larger population
hastings <- change*log(data$N - sum(mcmc$w) - mcmc$n)
}else if(change < 0){
hastings <- change*log(data$N - sum(mcmc$w) - mcmc$n)
}else{
hastings <- 0
}
if(log(runif(1)) < prop$e_lik + sum(prop$g_lik[-1]) + prop$prior - mcmc$e_lik - sum(mcmc$g_lik[-1]) - mcmc$prior + hastings){
return(prop)
}else{
return(mcmc)
}
}
for (r in 1:1000) {
mcmc <-moves$w(mcmc, data)
print(mcmc$w[158])
}
