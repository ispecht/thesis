#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
### Execute large-scale outbreak reconstruction algorithm
set.seed(229)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(cowplot)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
sourceCpp("cpp_subroutines.cpp")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_local = 10
data$sample_every = 10
data$n_global = 100
mcmc$psi <- 0.1 / (1.5 + 0.1)
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
# Run MCMC in parallel over each subtree
# Make the cluster
# cl <- makeCluster(length(mcmcs))
#
# all_res <- parallel::parLapply(
#   cl,
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     source("likelihood.R")
#     source("moves.R")
#     source("prior.R")
#     source("subroutines.R")
#     source("local_mcmc.R")
#
#     set.seed(213)
#
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas
# )
#
# stopCluster(cl)
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.set.seed = F,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
rates <- c()
times <- c()
for (i in 1:mcmc$n) {
rates[i] <- ((length(mcmc$m01[[i]]) + length(mcmc$m01[[i]])) / (mcmc$t[i] - mcmc$t[mcmc$h[i]]) / data$n_bases)
times[i] <- (mcmc$t[i] - mcmc$t[mcmc$h[i]])
}
plot(times, rates)
mean(rates, na.rm = T)
plot(times, mcmc$w)
plot(times, log(rates))
plot(times, sqrt(rates))
plot(times, 1/sqrt(rates))
plot(times, 1/(rates))
rates
plot(times, rates)
rates <- c()
times <- c()
for (i in 1:mcmc$n) {
rates[i] <- ((length(mcmc$m01[[i]]) + length(mcmc$m01[[i]])))
times[i] <- (mcmc$t[i] - mcmc$t[mcmc$h[i]])
}
plot(times, rates)
rates <- c()
times <- c()
for (i in 1:mcmc$n) {
rates[i] <- ((length(mcmc$m01[[i]]) + length(mcmc$m01[[i]])) / data$n_bases)
times[i] <- (mcmc$t[i] - mcmc$t[mcmc$h[i]])
}
plot(times, rates)
mean(rates/times)
mean(rates/times, na.rm= T)
gens <- gen(mcmc$h, mcmc$w)
G <- max(gens)
qs <- get_qs(mcmc$n - 1 + sum(mcmc$w), data$N, G, mcmc$rho, mcmc$psi)
qs
exp(qs)
mcmc$rho
gens <- gen(mcmc$h, mcmc$w)
G <- max(gens)
qs <- get_qs(mcmc$n - 1 + sum(mcmc$w), data$N, G, mcmc$rho, mcmc$psi)
out <- 0
which.max(gens)
i = 15
e_lik_node(mcmc$d[i], mcmc$w[i], qs[(gens[i] + 1 - mcmc$w[i]):(gens[i] + 1)], mcmc$rho, mcmc$psi)
mcmc$d[i]
mcmc$w[i]
qs[(gens[i] + 1 - mcmc$w[i]):(gens[i] + 1)]
e_lik_node(mcmc$d[i], 0, 0, mcmc$rho, mcmc$psi)
e_lik_node(mcmc$d[i], 1, 0, mcmc$rho, mcmc$psi)
e_lik_node(mcmc$d[i], 2, 0, mcmc$rho, mcmc$psi)
e_lik_node(mcmc$d[i], 1, qs[(gens[i] + 1-1):(gens[i] + 1)], mcmc$rho, mcmc$psi)
mcmc$psi
log(1-mcmc$psi) + mcmc$rho*log(mcmc$psi) - (mcmc$rho+1)*log(1 + exp(qs[gens[i]])*(mcmc$psi - 1)) + log(mcmc$rho)
log(1-mcmc$psi)
mcmc$rho*log(mcmc$psi)
- (mcmc$rho+1)*log(1 + exp(qs[gens[i]])*(mcmc$psi - 1))
log(mcmc$rho)
mcmc$rho
mcmc$psi
exp(qs[gens[i]])
gens <- gen(mcmc$h, mcmc$w)
G <- max(gens)
qs <- get_qs(mcmc$n - 1 + sum(mcmc$w), data$N, G, mcmc$rho, mcmc$psi)
out <- 0
for (i in 1:mcmc$n) {
print(e_lik_node(mcmc$d[i], mcmc$w[i], qs[(gens[i] + 1 - mcmc$w[i]):(gens[i] + 1)], mcmc$rho, mcmc$psi))
out <- out + e_lik_node(mcmc$d[i], mcmc$w[i], qs[(gens[i] + 1 - mcmc$w[i]):(gens[i] + 1)], mcmc$rho, mcmc$psi)
}
