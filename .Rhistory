dates <- cbind(names(cons), round(s[2:n]))
write.csv(dates, "./input_data/date.csv", row.names = F, quote = F)
# First, remove existing vcfs, just in case
do.call(file.remove, list(list.files("./input_data/vcf/", full.names = TRUE)))
# Write VCFs
for (i in 2:n) {
# Which positions have iSNVs in read data?
pos <- which(props[[i]] > 0 & props[[i]] < 1)
af <- props[[i]][pos]
alt_reads <- round(10000 * af)
info <- paste0(
"DP=",
10000,
";AF=",
format(round(alt_reads / 10000, 6), scientific = F),
";SB=0;DP4=0,", # strand bias wouldn't actually be 0 here, but assuming no strand bias in synthetic data
10000 - alt_reads,
",0,",
alt_reads
)
vcf <- data.frame(
CHROM = "ref",
POS = pos,
ID = ".",
REF = "A",
ALT = "C",
QUAL = 5000,
FILTER = "PASS",
INFO = info
)
write.table(vcf, file = paste0("./input_data/vcf/", names[i], ".vcf"), col.names = F, row.names = F)
}
### Reconstruction
init <- initialize(exact_coalescent = F)
mcmc <- init[[1]]
data <- init[[2]]
mcmc$rho <- 0.5
mcmc$psi <- 0.5/(0.5 + 1.5)
if(misspecify == 1){
mcmc$psi = 0.5/(0.5 + 2.5)
}
if(misspecify == 2){
mcmc$a_g <- 6
}
if(misspecify == 3){
mcmc$a_s = 6
}
data$n_local = 10
data$sample_every = 10
data$n_global = 100
output <- run_mcmc(mcmc, data, noisy = F)
## Analysis
adj <- get_adj(output[[2]], data$n_obs)
# Overall accuracy
acc <- mean(adj[cbind(h[2:n], 2:n)])
# What proportion of ancestral choices with a probability >50% are correct?
hits <- c()
for (i in 1:n) {
if(any(adj[,i] > 0.5)){
who <- which(adj[,i] > 0.5)
if(h[i] == who){
hits <- c(hits, 1)
}else{
hits <- c(hits, 0)
}
}
}
hits <- ifelse(length(hits) == 0, NA, mean(hits))
# Does a (minimum-cardinality) 50% posterior interval contain the correct ancestor?
cover <- c()
for (i in 1:n) {
ord <- sort.int(adj[,i], index.return = T, decreasing = T)$ix
csum <- cumsum(adj[ord,i])
if(max(csum) > 0.5){
first <- min(which(csum > 0.5))
who <- ord[1:first]
if(h[i] %in% who){
cover <- c(cover, 1)
}else{
cover <- c(cover, 0)
}
}
}
cover <- ifelse(length(cover) == 0, NA, mean(cover))
# for (i in 1:(n-1)) {
#   print(sum(cons[[i]] == "C"))
# }
## Go back to root directory
setwd('..')
setwd('..')
# Return accuracy
return(
c(
acc,
hits,
cover
)
)
}
i = 1
getwd()
sim_stats <- mclapply(1:100, run_sim, misspecify = i, mc.cores = 12)
i = 0
sim_stats <- mclapply(1:100, run_sim, misspecify = i, mc.cores = 12)
sim_stats <- as.data.frame(matrix(unlist(sim_stats), ncol = 3, byrow = T))
colnames(sim_stats) <- c("Accuracy", "Hit Rate", "Coverage")
sim_stats <- melt(sim_stats)
colnames(sim_stats)[1] <- "Metric"
ggplot(sim_stats, aes(x = Metric)) +
geom_boxplot(aes(y=value, color = Metric, fill = Metric)) +
scale_fill_manual(values = c("pink", "lightgreen", "lightblue")) +
scale_color_manual(values = c("darkred", "darkgreen", "darkblue")) +
xlab("Metric") +
ylab("Value") +
theme_minimal() +
theme(legend.position = 'none')
getwd()
source("main.R")
## Unhash these for regular run
init <- initialize(init_mst = T, exact_coalescent = F)
#init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_local = 10
data$sample_every = 10
data$n_global = 100
noisy = T
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
if(noisy){
message(paste("Parallelizing over", length(mcmcs), "cores..."))
}
# all_res <- parallel::mclapply(
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas,
#   mc.set.seed = F,
#   mc.cores = length(mcmcs)
# )
#...or run in series
all_res <- list()
for (j in 1:length(mcmcs)) {
all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
}
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
if(noisy){
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$rho * (1 - mcmc$psi) / mcmc$psi)
# print(length(unlist(mcmc$m01)) + length(unlist(mcmc$m10)))
# print(length(unlist(mcmc$mx1)))
#print(data$s - mcmc$t[1:data$n_obs])
#print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
}
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
if(noisy){
message(paste("Parallelizing over", length(mcmcs), "cores..."))
}
# all_res <- parallel::mclapply(
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas,
#   mc.set.seed = F,
#   mc.cores = length(mcmcs)
# )
#...or run in series
all_res <- list()
for (j in 1:length(mcmcs)) {
all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
}
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
if(noisy){
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$rho * (1 - mcmc$psi) / mcmc$psi)
# print(length(unlist(mcmc$m01)) + length(unlist(mcmc$m10)))
# print(length(unlist(mcmc$mx1)))
#print(data$s - mcmc$t[1:data$n_obs])
#print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
}
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
rates <- c()
times <- c()
for (i in 2:mcmc$n) {
rates[i] <- ((length(mcmc$m01[[i]]) + length(mcmc$m10[[i]])) / data$n_bases)
times[i] <- (mcmc$t[i] - mcmc$t[mcmc$h[i]])
}
plot(times, rates)
#mean(rates/times, na.rm = T)
sum(rates, na.rm = T) / sum(times, na.rm = T)
plot(times, mcmc$w+1)
mean(times/ (mcmc$w + 1), na.rm = T)
n_snv <- c()
n_isnv <- c()
for (i in 1:data$n_obs) {
n_snv[i] <- length(data$snvs[[i]]$snv$call)/data$n_bases/data$s[i]
n_isnv[i] <- length(data$snvs[[i]]$isnv$call)
}
mean(n_snv, na.rm = T)
source("main.R")
## Unhash these for regular run
init <- initialize(init_mst = T, exact_coalescent = F)
#init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_local = 10
data$sample_every = 10
data$n_global = 100
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
if(noisy){
message(paste("Parallelizing over", length(mcmcs), "cores..."))
}
# all_res <- parallel::mclapply(
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas,
#   mc.set.seed = F,
#   mc.cores = length(mcmcs)
# )
#...or run in series
all_res <- list()
for (j in 1:length(mcmcs)) {
all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
}
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
if(noisy){
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$rho * (1 - mcmc$psi) / mcmc$psi)
# print(length(unlist(mcmc$m01)) + length(unlist(mcmc$m10)))
# print(length(unlist(mcmc$mx1)))
#print(data$s - mcmc$t[1:data$n_obs])
#print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
}
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
rates <- c()
times <- c()
for (i in 2:mcmc$n) {
rates[i] <- ((length(mcmc$m01[[i]]) + length(mcmc$m10[[i]])) / data$n_bases)
times[i] <- (mcmc$t[i] - mcmc$t[mcmc$h[i]])
}
plot(times, rates)
#mean(rates/times, na.rm = T)
sum(rates, na.rm = T) / sum(times, na.rm = T)
plot(times, mcmc$w+1)
mean(times/ (mcmc$w + 1), na.rm = T)
n_snv <- c()
n_isnv <- c()
for (i in 1:data$n_obs) {
n_snv[i] <- length(data$snvs[[i]]$snv$call)/data$n_bases/data$s[i]
n_isnv[i] <- length(data$snvs[[i]]$isnv$call)
}
mean(n_snv, na.rm = T)
source("main.R")
## Unhash these for regular run
init <- initialize(init_mst = T, exact_coalescent = F)
#init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_local = 10
data$sample_every = 10
data$n_global = 100
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
if(noisy){
message(paste("Parallelizing over", length(mcmcs), "cores..."))
}
# all_res <- parallel::mclapply(
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas,
#   mc.set.seed = F,
#   mc.cores = length(mcmcs)
# )
#...or run in series
all_res <- list()
for (j in 1:length(mcmcs)) {
all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
}
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
if(noisy){
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$rho * (1 - mcmc$psi) / mcmc$psi)
# print(length(unlist(mcmc$m01)) + length(unlist(mcmc$m10)))
# print(length(unlist(mcmc$mx1)))
#print(data$s - mcmc$t[1:data$n_obs])
#print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
}
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
source("main.R")
## Unhash these for regular run
init <- initialize(init_mst = T, exact_coalescent = T)
#init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_local = 10
data$sample_every = 10
data$n_global = 100
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# For reproducible results
#set.seed(r)
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
if(noisy){
message(paste("Parallelizing over", length(mcmcs), "cores..."))
}
# all_res <- parallel::mclapply(
#   1:length(mcmcs),
#   function(i, mcmcs, datas){
#     local_mcmc(mcmcs[[i]], datas[[i]])
#   },
#   mcmcs = mcmcs,
#   datas = datas,
#   mc.set.seed = F,
#   mc.cores = length(mcmcs)
# )
#...or run in series
all_res <- list()
for (j in 1:length(mcmcs)) {
all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
}
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
if(noisy){
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
print(mcmc$mu)
print(mcmc$p)
print(mcmc$rho * (1 - mcmc$psi) / mcmc$psi)
# print(length(unlist(mcmc$m01)) + length(unlist(mcmc$m10)))
# print(length(unlist(mcmc$mx1)))
#print(data$s - mcmc$t[1:data$n_obs])
#print(mcmc$lambda)
#print(mcmc$h)
# print(mcmc$a_g)
}
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
source("main.R")
## Unhash these for regular run
init <- initialize(init_mst = T, exact_coalescent = T)
#init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
data$n_local = 10
data$sample_every = 10
data$n_global = 100
a_gs <- c(4, 6) # Default = 5
lambda_gs <- a_gs/5 # Default = 1. Also update a_g to maintain mean of 5. Corresponds to variance of 5 (default), 25, 1
a_ss <- c(4, 6) # Default = 5
lambda_ss <- a_ss/5 # Default = 1. Also update a_s to maintain mean of 5. Corresponds to variance of 5 (default), 25, 1
rhos <- c(0.05, 0.2) # Default = 0.1. Also update psi = rho / (2.5 + rho)
psis <- 0.1 / (c(1.5, 3.5) + 0.1)
vs <- c(500, 2000)
# jth column is corresponds to each of the above params, in order
combos <- matrix(c(5, 1, 5, 1, 0.1, 0.1/(2.5 + 0.1), 1000), nrow = 15, ncol = 7, byrow = T)
combos[1:2, 1] <- a_gs
combos[3:4, 1] <- lambda_gs * 5
combos[3:4, 2] <- lambda_gs
combos[5:6, 3] <- a_ss
combos[7:8, 3] <- lambda_ss * 5
combos[7:8, 4] <- lambda_ss
combos[9:10, 5] <- rhos
combos[9:10, 6] <- rhos / (2.5 + rhos)
combos[11:12, 6] <- psis
combos[13:14, 7] <- vs
combos
