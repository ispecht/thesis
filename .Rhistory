}
n <- length(h)
#identical(d[2:n], sapply(2:n, function(x){length(which(h == x))}))
#calc_d <- sapply(2:n, function(x){length(which(h == x))})
mcmc <- list()
mcmc$n <- n
mcmc$h <- h
mcmc$d <- d
data <- list()
data$n_subtrees = 224
data$n_obs <- 45261
chop(mcmc, data)
breakdown <- chop(mcmc, data)
breakdown[[2]][[156]]
breakdown[[1]]
max(breakdown[[1]])
h[breakdown[[2]][[156]]] %in% breakdown[[2]][[156]]
h[breakdown[[2]][[155]]] %in% breakdown[[2]][[155]]
h[breakdown[[2]][[4]]] %in% breakdown[[2]][[4]]
h[breakdown[[2]][[156]]] %in% breakdown[[2]][[156]]
h[breakdown[[2]][[156]]] %in% c(breakdown[[2]][[156]], breakdown[[1]][156])
for (i in 1:length(breakdown[[1]])) {
print(all(h[breakdown[[2]][[i]]] %in% c(breakdown[[2]][[i]], breakdown[[1]][i])))
}
ancestry(h, 10000)
for (i in 1:n) {
print(ancestry(h, i)[1])
}
heh <- c()
for (i in 1:n) {
heh[i] <- (ancestry(h, i)[1])
}
all(heh == 1)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
14694 - 12722
which(output== "$w")
output[6000]
output[5000]
output[5500]
output[5800]
output[5900]
output[5950]
output[5920]
output[5925]
output[5924]
which(output == "$t")
output[8000]
output[9000]
output[12000]
output[12720]
output[12719]
output[12710]
output[12700]
output[12680]
output[12690]
output[12685]
output[12688]
output[12689]
## Try to diagnose failure of MCMC
source("subroutines.R")
output <- readLines("ispecht_nohup.out")
h_part <- output[5:3949]
w_part <- output[3951:5924]
t_part <- output[5926:12689]
d_part <- output[12722:14694]
convert <- function(h_part){
h_part <- gsub(".*\\]", "", h_part)
h <- c()
for (i in 1:length(h_part)) {
str <- strsplit(h_part[i], " ")[[1]]
str <- str[str != ""]
str <- as.numeric(str)
h <- c(h, str)
}
h
}
mcmc <- list()
mcmc$n <- length(h)
mcmc$h <- convert(h_part)
mcmc$w <- convert(w_part)
mcmc$t <- convert(t_part)
mcmc$b <- 0.5019677
mcmc$a_g <- 5
mcmc$lambda_g <- 1
mcmc$a_s <- 5
mcmc$lambda_s <- 1
mcmc$mu <- 8.420836e-07
mcmc$p <- 5.97107e-08
mcmc$v <- 147
mcmc$rho <- 0.1
mcmc$psi <- 0.03846154
mcmc$d <- convert(d_part)
w_part
h_part <- w_part
h_part <- gsub(".*\\]", "", h_part)
h_part
h <- c()
str <- strsplit(h_part[i], " ")[[1]]
str <- str[str != ""]
str <- as.numeric(str)
h <- c(h, str)
h <- c()
i = 1
str <- strsplit(h_part[i], " ")[[1]]
str <- str[str != ""]
str <- as.numeric(str)
i = 1
str <- strsplit(h_part[i], " ")[[1]]
str <- str[str != ""]
str
output[3951]
w_part <- output[3951:5924]
w_part[1]
w_part
t_part <- output[5926:12689]
t_part[1]
## Try to diagnose failure of MCMC
source("subroutines.R")
output <- readLines("ispecht_nohup.out")
h_part <- output[5:3949]
w_part <- output[3952:5924]
t_part <- output[5927:12689]
d_part <- output[12722:14694]
convert <- function(h_part){
h_part <- gsub(".*\\]", "", h_part)
h <- c()
for (i in 1:length(h_part)) {
str <- strsplit(h_part[i], " ")[[1]]
str <- str[str != ""]
str <- as.numeric(str)
h <- c(h, str)
}
h
}
mcmc <- list()
mcmc$n <- length(h)
mcmc$h <- convert(h_part)
mcmc$w <- convert(w_part)
mcmc$t <- convert(t_part)
mcmc$b <- 0.5019677
mcmc$a_g <- 5
mcmc$lambda_g <- 1
mcmc$a_s <- 5
mcmc$lambda_s <- 1
mcmc$mu <- 8.420836e-07
mcmc$p <- 5.97107e-08
mcmc$v <- 147
mcmc$rho <- 0.1
mcmc$psi <- 0.03846154
mcmc$d <- convert(d_part)
length(mcmc$t)
length(mcmc$w)
load("data.RData")
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
data$n_obs
subtrees <- chop(mcmc, data)
mcmc
# Initial tree (will change)
h <- mcmc$h
# Node degrees
d <- mcmc$d
# Traverse the tree in reverse-BFS order
ord <- rev(bfs(1, h))
# Minimum number of nodes per subtree
lambda <- mcmc$n / data$n_subtrees
# Tree outputs (not including roots)
trees <- list()
# Root outputs
roots <- c()
# All upstream nodes, not including self
w <- rep(0, mcmc$n)
data$n_obs
for (v in ord) {
if(v == 1){
sub <- bfs(v, h)
trees <- c(trees, list(sort(sub[-1])))
roots <- c(roots, v)
}else{
# Update number of upstream nodes of vertex v
if(d[v] > 0){
kids <- which(h == v)
if(length(kids) > 0){
w[v] <- w[v] + length(kids) + sum(w[kids])
}
}
# If weight is large enough, and root is observed, hack off a piece of the tree
if(
w[v] >= lambda &
v <= data$n_obs
){
if(mcmc$n - length(unlist(trees)) - w[v] >= lambda){
sub <- bfs(v, h)
trees <- c(trees, list(sort(sub[-1])))
roots <- c(roots, v)
# Delete nodes from tree, except root
## CHECK kids is correct
h[kids] <- NA
# Reset upstream nodes of root to nothing
w[v] <- 0
}
}
}
}
v
w[v]
mcmc$n
mcmc$h
length(mcmc$h)
mcmc$n <- 47340
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
j = 156
local_mcmc(mcmcs[[j]], datas[[j]])
j = 155
local_mcmc(mcmcs[[j]], datas[[j]])
j = 1
local_mcmc(mcmcs[[j]], datas[[j]])
mcmc0 <- mcmc
data0 <- data
mcmcs[[1]]
snvs <- data$snvs
mcmc$m01 <- list() # fixed mutations added in each transmission link
mcmc$m10 <- list() # fixed mutations deleted in each transmission link
mcmc$m0y <- list() # 0% -> y%, 0 < y < 100
mcmc$m1y <- list() # 100% -> y%, 0 < y < 100
mcmc$mx0 <- list() # x% -> 0%, 0 < x < 100
mcmc$mx1 <- list() # x% -> 100%, 0 < x < 100
mcmc$mxy <- list() # x% -> y%, 0 < x < 100, 0 < y < 100
for (i in 1:n) {
mcmc$m01[[i]] <- snvs[[i]]$snv$call
mcmc$m10[[i]] <- character(0)
mcmc$m0y[[i]] <- snvs[[i]]$isnv$call
mcmc$m1y[[i]] <- character(0)
mcmc$mx0[[i]] <- character(0)
mcmc$mx1[[i]] <- character(0)
mcmc$mxy[[i]] <- character(0)
}
n <- data$n_obs
mcmc$m01 <- list() # fixed mutations added in each transmission link
mcmc$m10 <- list() # fixed mutations deleted in each transmission link
mcmc$m0y <- list() # 0% -> y%, 0 < y < 100
mcmc$m1y <- list() # 100% -> y%, 0 < y < 100
mcmc$mx0 <- list() # x% -> 0%, 0 < x < 100
mcmc$mx1 <- list() # x% -> 100%, 0 < x < 100
mcmc$mxy <- list() # x% -> y%, 0 < x < 100, 0 < y < 100
for (i in 1:n) {
mcmc$m01[[i]] <- snvs[[i]]$snv$call
mcmc$m10[[i]] <- character(0)
mcmc$m0y[[i]] <- snvs[[i]]$isnv$call
mcmc$m1y[[i]] <- character(0)
mcmc$mx0[[i]] <- character(0)
mcmc$mx1[[i]] <- character(0)
mcmc$mxy[[i]] <- character(0)
}
init_h <- mcmc$h
mcmc$h
gens <- generations(init_h, 1)
max_t <- min(s[2:n] - 5)
message("Initializing transmission network...")
progress <- 0
pb = txtProgressBar(min = 0, max = n, initial = 0)
for (g in 2:length(gens)) {
for (i in gens[[g]]) {
if(g >= 3){
anc <- ancestry(init_h, i)
for (j in 2:(length(anc) - 1)) {
mcmc <- update_genetics_upstream(mcmc, mcmc, i, anc[j])
mcmc$m01[[j]] <- setdiff(mcmc$m01[[j]], snvs[[j]]$missing$call) # Remove calls for missing positions
mcmc$m10[[j]] <- setdiff(mcmc$m10[[j]], snvs[[j]]$missing$call)
}
}
mcmc$t[i] <- max_t - 5*(length(gens) - g)
progress <- progress + 1
setTxtProgressBar(pb,progress)
}
}
s <- data$s
gens <- generations(init_h, 1)
max_t <- min(s[2:n] - 5)
message("Initializing transmission network...")
progress <- 0
pb = txtProgressBar(min = 0, max = n, initial = 0)
for (g in 2:length(gens)) {
for (i in gens[[g]]) {
if(g >= 3){
anc <- ancestry(init_h, i)
for (j in 2:(length(anc) - 1)) {
mcmc <- update_genetics_upstream(mcmc, mcmc, i, anc[j])
mcmc$m01[[j]] <- setdiff(mcmc$m01[[j]], snvs[[j]]$missing$call) # Remove calls for missing positions
mcmc$m10[[j]] <- setdiff(mcmc$m10[[j]], snvs[[j]]$missing$call)
}
}
mcmc$t[i] <- max_t - 5*(length(gens) - g)
progress <- progress + 1
setTxtProgressBar(pb,progress)
}
}
mcmcs[[156]]
subtrees <- chop(mcmc, data)
unlist(subtrees[[2]])
mcmc$n
length(unique(unlist(subtrees[[2]])))
amalgamate(list(mcmcs), mcmcs, datas, mcmc, data)
for (i in 1:length(mcmcs)) {
print(mcmcs[[i]]$h)
}
print(sum(is.na(mcmcs[[i]]$h)))
for (i in 1:length(mcmcs)) {
print(sum(is.na(mcmcs[[i]]$h)))
}
print(sum(mcmcs[[i]]$d[2:mcmcs[[i]]$n] != sapply(2:mcmcs[[i]]$n, function(x){sum(mcmcs[[i]]$h[2:mcmcs[[i]]$n] == x)})))
for (i in 1:length(mcmcs)) {
print(sum(mcmcs[[i]]$d[2:mcmcs[[i]]$n] != sapply(2:mcmcs[[i]]$n, function(x){sum(mcmcs[[i]]$h[2:mcmcs[[i]]$n] == x)})))
#print(sum(is.na(mcmcs[[i]]$h)))
}
mcmcs[[i]]$frozen
datas <- breakdowns[[2]]
for (i in 1:length(mcmcs)) {
#print(sum(mcmcs[[i]]$d[2:mcmcs[[i]]$n] != sapply(2:mcmcs[[i]]$n, function(x){sum(mcmcs[[i]]$h[2:mcmcs[[i]]$n] == x)})))
print(datas[[i]]$frozen)
}
all_freeze <- c()
for (i in 1:length(mcmcs)) {
#print(sum(mcmcs[[i]]$d[2:mcmcs[[i]]$n] != sapply(2:mcmcs[[i]]$n, function(x){sum(mcmcs[[i]]$h[2:mcmcs[[i]]$n] == x)})))
all_freeze <- c(all_freeze, datas[[i]]$frozen)
}
all_freeze
length(all_freeze)
length(unique(all_freeze))
source("subroutines.R")
output <- readLines("ispecht_nohup.out")
h_part <- output[5:3949]
w_part <- output[3952:5924]
t_part <- output[5927:12689]
d_part <- output[12722:14694]
convert <- function(h_part){
h_part <- gsub(".*\\]", "", h_part)
h <- c()
for (i in 1:length(h_part)) {
str <- strsplit(h_part[i], " ")[[1]]
str <- str[str != ""]
str <- as.numeric(str)
h <- c(h, str)
}
h
}
mcmc <- list()
mcmc$n <- 47340
mcmc$h <- convert(h_part)
mcmc$w <- convert(w_part)
mcmc$t <- convert(t_part)
mcmc$m01 <- list() # fixed mutations added in each transmission link
mcmc$m10 <- list() # fixed mutations deleted in each transmission link
mcmc$m0y <- list() # 0% -> y%, 0 < y < 100
mcmc$m1y <- list() # 100% -> y%, 0 < y < 100
mcmc$mx0 <- list() # x% -> 0%, 0 < x < 100
mcmc$mx1 <- list() # x% -> 100%, 0 < x < 100
mcmc$mxy <- list() # x% -> y%, 0 < x < 100, 0 < y < 100
for (i in 1:mcmc$n) {
mcmc$m01[[i]] <- character(0)
mcmc$m10[[i]] <- character(0)
mcmc$m0y[[i]] <- character(0)
mcmc$m1y[[i]] <- character(0)
mcmc$mx0[[i]] <- character(0)
mcmc$mx1[[i]] <- character(0)
mcmc$mxy[[i]] <- character(0)
}
mcmc$b <- 0.5019677
mcmc$a_g <- 5
mcmc$lambda_g <- 1
mcmc$a_s <- 5
mcmc$lambda_s <- 1
mcmc$mu <- 8.420836e-07
mcmc$p <- 5.97107e-08
mcmc$v <- 147
mcmc$rho <- 0.1
mcmc$psi <- 0.03846154
mcmc$d <- convert(d_part)
e_lik(mcmc, data)
mcmc$g_lik <- c(NA, sapply(2:mcmc$n, g_lik, mcmc=mcmc, data=data))
mcmc$g_lik
mcmc$prior <- prior(mcmc)
mcmc$prior
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
j
j = 156
local_mcmc(mcmcs[[j]], datas[[j]])
datas[[156]]$snvs
datas[[j]]$snvs[[1]]
j = 168
local_mcmc(mcmcs[[j]], datas[[j]])
data$n_obs
table(mcmc$h)
sum(is.na(mcmc$h))
data$n_local = 1
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
all_res <- list()
for (j in 1:length(mcmcs)) {
all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
}
mcmcs[[156]]
mcmcs[[157]]
mcmcs[[157]]$cluster
### Execute large-scale outbreak reconstruction algorithm
set.seed(220)
## Libraries
library(ape)
library(Rcpp)
#library(igraph)
#library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
# init <- initialize()
#
mcmc <- init[[1]]
### Execute large-scale outbreak reconstruction algorithm
set.seed(220)
## Libraries
library(ape)
library(Rcpp)
#library(igraph)
#library(ggraph)
library(parallel)
source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")
## Unhash these for regular run
init <- initialize()
mcmc <- init[[1]]
data <- init[[2]]
## Unhash these for run on pre-computed data and initial MCMC
#load("data.RData")
#load("mcmc.RData")
### M-H algo
output <- list()
liks <- c()
for (r in 1:data$n_global) {
# Make global moves
mcmc <- global_mcmc(mcmc, data)
# Chop up the tree into pieces
breakdowns <- breakdown(mcmc, data)
mcmcs <- breakdowns[[1]]
datas <- breakdowns[[2]]
message(paste("Parallelizing over", length(mcmcs), "cores..."))
save(mcmcs, file = "mcmcs.RData")
# Run MCMC in parallel over each subtree
all_res <- parallel::mclapply(
1:length(mcmcs),
function(i, mcmcs, datas){
local_mcmc(mcmcs[[i]], datas[[i]])
},
mcmcs = mcmcs,
datas = datas,
mc.cores = length(mcmcs)
)
#...or run in series
# all_res <- list()
# for (j in 1:length(mcmcs)) {
#   all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
# }
# Amalgamate results of parallel MCMC run
amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)
# Record amalgamated results, filtering to parameters of interest
for (i in 1:length(amalgam)) {
output <- c(output, list(
amalgam[[i]][data$record]
))
}
# "mcmc" is now the most recent result
mcmc <- amalgam[[length(amalgam)]]
#print(r)
liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)
message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
#print(plot_current(mcmc$h, data$n_obs))
#print(mcmc$w)
# if(r == 10){
#   data$n_subtrees <- 3
# }
}
