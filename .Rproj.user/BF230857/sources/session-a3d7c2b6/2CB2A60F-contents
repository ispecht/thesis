### Execute large-scale outbreak reconstruction algorithm
set.seed(232)
## Libraries
library(ape)
library(Rcpp)
library(igraph)
library(ggraph)
library(ggplot2)
library(cowplot)
library(parallel)

source("likelihood.R")
source("moves.R")
source("prior.R")
source("subroutines.R")
sourceCpp("cpp_subroutines.cpp")
source("initialize.R")
source("global_mcmc.R")
source("local_mcmc.R")

### M-H algo
run_mcmc <- function(mcmc, data, noisy = F){
  output <- list()
  liks <- c()

  for (r in 1:data$n_global) {

    # For reproducible results
    #set.seed(r)

    # Make global moves
    mcmc <- global_mcmc(mcmc, data)

    # Chop up the tree into pieces
    breakdowns <- breakdown(mcmc, data)
    mcmcs <- breakdowns[[1]]
    datas <- breakdowns[[2]]

    if(noisy){
      message(paste("Parallelizing over", length(mcmcs), "cores..."))
    }

    # all_res <- parallel::mclapply(
    #   1:length(mcmcs),
    #   function(i, mcmcs, datas){
    #     local_mcmc(mcmcs[[i]], datas[[i]])
    #   },
    #   mcmcs = mcmcs,
    #   datas = datas,
    #   mc.set.seed = F,
    #   mc.cores = length(mcmcs)
    # )
    #...or run in series
    all_res <- list()
    for (j in 1:length(mcmcs)) {
      all_res[[j]] <- local_mcmc(mcmcs[[j]], datas[[j]])
    }

    # Amalgamate results of parallel MCMC run
    amalgam <- amalgamate(all_res, mcmcs, datas, mcmc, data)

    # Record amalgamated results, filtering to parameters of interest
    for (i in 1:length(amalgam)) {
      output <- c(output, list(
        amalgam[[i]][data$record]
      ))
    }

    # "mcmc" is now the most recent result
    mcmc <- amalgam[[length(amalgam)]]

    #print(r)

    liks <- c(liks, mcmc$e_lik + sum(mcmc$g_lik[2:mcmc$n]) + mcmc$prior)


    if(noisy){
      message(paste(r, "global iterations complete. Log-likelihood =", round(liks[r], 2)))
      print(plot_current(mcmc$h, data$n_obs))
      #print(mcmc$w)
       print(mcmc$mu)
       print(mcmc$p)
       print(mcmc$rho * (1 - mcmc$psi) / mcmc$psi)
      # print(length(unlist(mcmc$m01)) + length(unlist(mcmc$m10)))
      # print(length(unlist(mcmc$mx1)))
      #print(data$s - mcmc$t[1:data$n_obs])
      #print(mcmc$lambda)
      #print(mcmc$h)
      # print(mcmc$a_g)
    }


    # if(r == 10){
    #   data$n_subtrees <- 3
    # }

  }
  return(list(
    liks, output
  ))
}

# rates <- c()
# times <- c()
# for (i in 2:mcmc$n) {
#   rates[i] <- ((length(mcmc$m01[[i]]) + length(mcmc$m10[[i]])) / data$n_bases)
#   times[i] <- (mcmc$t[i] - mcmc$t[mcmc$h[i]])
# }
# plot(times, rates)
# #mean(rates/times, na.rm = T)
# sum(rates, na.rm = T) / sum(times, na.rm = T)
# plot(times, mcmc$w+1)
# mean(times/ (mcmc$w + 1), na.rm = T)
#
# n_snv <- c()
# n_isnv <- c()
# for (i in 1:data$n_obs) {
#   n_snv[i] <- length(data$snvs[[i]]$snv$call)/data$n_bases/data$s[i]
#   n_isnv[i] <- length(data$snvs[[i]]$isnv$call)
# }
# mean(n_snv, na.rm = T)

# hehe <- run_mcmc(mcmc, data)




